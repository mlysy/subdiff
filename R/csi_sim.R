#' Simulate increments of a CSI process.
#'
#' @param drift Matrix of `(nobs-1) x ndim` increment drift terms (see 'Details').
#' @param acf Increment autocorrelation vector of length `nobs-1` (see 'Details').
#' @param Sigma Variance matrix of size `ndim x ndim`.
#' @param X0 Initial position vector of length `ndim`.
#' @param nsim Number of trajectories to simulate.
#' @param fft,nkeep,tol Optional arguments to [SuperGauss::rnormtz()].
#'
#' @return The simulated trajectories.  An array of size `nobs x ndim x nsim` or a matrix of size `nobs x ndim` when `nsim = 1`.
#'
#' @details Given an `(nobs-1) x ndim` matrix of iid standard normals `Z`, an `nobs x ndim` trajectory matrix is generated by
#' ```
#' dX = toeplitz(acf)^{1/2} %*% Z %*% Sigma^{1/2} + drift
#' X = apply(rbind(X0, dX), 2, cumsum)
#' ```
#' @export
csi_sim <- function(drift, acf, Sigma, X0, nsim = 1,
                    fft = TRUE, nkeep, tol = 1e-6) {
  ndim <- nrow(Sigma)
  # generate toeplitz(acf)^{1/2} %*% Z
  Z <- SuperGauss::rnormtz(n = nsim*ndim, acf = acf,
                           fft = fft, nkeep = nkeep, tol = tol)
  csi_ZX(Z, drift, Sigma, X0, nsim)
}

#--- helper functions ----------------------------------------------------------

#' Convert `Z` to `Xt`.
#'
#' This just makes debugging [csi_sim()] easier.
#' @noRd
csi_ZX <- function(Z, drift, Sigma, X0, nsim) {
  ndim <- nrow(Sigma)
  # stack columns for multiplication by Sigma^{1/2}
  nobs <- nrow(Z) + 1
  Z <- matrix(Z, nrow = (nobs-1) * nsim, ndim)
  dX <- Z %*% chol(Sigma)
  # convert to 3D array for adding drift and cumsum
  dX <- aperm(array(dX, dim = c(nobs-1, nsim, ndim)), c(1,3,2))
  Xt <- array(NA, dim = c(nobs, ndim, nsim))
  Xt[-1,,] <- c(dX) + c(drift)
  Xt[1,,] <- X0
  # increments to positions
  Xt <- apply(Xt, 2:3, cumsum)
  if(nsim == 1) Xt <- matrix(Xt, nobs, ndim)
  Xt
}

#--- scratch -------------------------------------------------------------------

## Sigma <- crossprod(matrix(rnorm(9), 3, 3))
## ed <- eigen(Sigma)
## U <- chol(Sigma) # diag(sqrt(ed$values)) %*% t(ed$vectors)
## Sigma - crossprod(U)
## Sigma - ed$vectors %*% diag(ed$values) %*% t(ed$vectors)
