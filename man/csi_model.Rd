% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/csi_model.R
\name{csi_model}
\alias{csi_model}
\title{Base class for CSI models.}
\description{
Base class for CSI models.
}
\note{
The MSD of some models (e.g., \code{fsd} and \code{farma}) is not defined in continuous time, and thus depends on the interobservation time \code{dt}.  This is completely overlooked in \code{csi_model$msd()} as it is presently coded, which is potentially misleading.  Need to think carefully about what the \code{msd()} method should do.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{phi_names}}{Vector of kernel parameter names (on the original scale).  Setting to \code{NULL} means there are no kernel parameters (\code{n_phi = 0}).}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{Xt}}{Particle trajectory.  A matrix where row \code{n} is the position of the particle at time \code{t = n * dt} and each column is a measurement dimension.  Only reallocates memory for the internal Toeplitz matrix if necessary.}

\item{\code{dt}}{Interobservation time (scalar).}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-trans}{\code{csi_model$trans()}}
\item \href{#method-itrans}{\code{csi_model$itrans()}}
\item \href{#method-acf}{\code{csi_model$acf()}}
\item \href{#method-msd}{\code{csi_model$msd()}}
\item \href{#method-drift}{\code{csi_model$drift()}}
\item \href{#method-get_omega}{\code{csi_model$get_omega()}}
\item \href{#method-trans_full}{\code{csi_model$trans_full()}}
\item \href{#method-itrans_full}{\code{csi_model$itrans_full()}}
\item \href{#method-nlp}{\code{csi_model$nlp()}}
\item \href{#method-nu_hat}{\code{csi_model$nu_hat()}}
\item \href{#method-loglik}{\code{csi_model$loglik()}}
\item \href{#method-fisher}{\code{csi_model$fisher()}}
\item \href{#method-get_vcov}{\code{csi_model$get_vcov()}}
\item \href{#method-fit}{\code{csi_model$fit()}}
\item \href{#method-resid}{\code{csi_model$resid()}}
\item \href{#method-sim}{\code{csi_model$sim()}}
\item \href{#method-new}{\code{csi_model$new()}}
\item \href{#method-clone}{\code{csi_model$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-trans"></a>}}
\if{latex}{\out{\hypertarget{method-trans}{}}}
\subsection{Method \code{trans()}}{
Transform kernel parameters from regular to computational basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$trans(phi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Kernel parameters in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-itrans"></a>}}
\if{latex}{\out{\hypertarget{method-itrans}{}}}
\subsection{Method \code{itrans()}}{
Transform kernel parameters from computational to regular basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$itrans(psi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi}}{Kernel parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Kernel parameters in the original basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-acf"></a>}}
\if{latex}{\out{\hypertarget{method-acf}{}}}
\subsection{Method \code{acf()}}{
Increment autocorrelation function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$acf(phi, dt, N)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{dt}}{Interobservation time.}

\item{\code{N}}{Number of trajectory increments.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector of \code{N} autocorrelations.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-msd"></a>}}
\if{latex}{\out{\hypertarget{method-msd}{}}}
\subsection{Method \code{msd()}}{
Position mean square displacement function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$msd(phi, t)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{t}}{Vector of time points at which to calculate the MSD.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This function can be directly supplied by the derived class, or by default is derived automatically from a high-resolution evaluation of \code{super$acf()}.  That is, with \code{dt} being up to 10x smaller than \code{min(diff(sort(abs(t))))}.  Thus the default method is most efficient when \code{t} consists of evenly spaced timepoints, and most wasteful when two time points are much closer than any others.
}

\subsection{Returns}{
A vector of MSD values the same length as \code{t}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-drift"></a>}}
\if{latex}{\out{\hypertarget{method-drift}{}}}
\subsection{Method \code{drift()}}{
Increment autocorrelation function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$drift(phi, dt, N)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{dt}}{Interobservation time.}

\item{\code{N}}{Number of trajectory increments.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \verb{N x n_drift} matrix of drift basis functions.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_omega"></a>}}
\if{latex}{\out{\hypertarget{method-get_omega}{}}}
\subsection{Method \code{get_omega()}}{
Combine kernel parameters with conditional MLE of \code{mu} and \code{Sigma}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$get_omega(psi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi}}{Kernel parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Named vector of full parameter set in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-trans_full"></a>}}
\if{latex}{\out{\hypertarget{method-trans_full}{}}}
\subsection{Method \code{trans_full()}}{
Convert from original to computational basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$trans_full(phi, mu, Sigma)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Full parameter vector in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-itrans_full"></a>}}
\if{latex}{\out{\hypertarget{method-itrans_full}{}}}
\subsection{Method \code{itrans_full()}}{
Convert from computational to original basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$itrans_full(omega)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{omega}}{Vector of parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements \code{phi}, \code{mu}, and \code{Sigma}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nlp"></a>}}
\if{latex}{\out{\hypertarget{method-nlp}{}}}
\subsection{Method \code{nlp()}}{
Evaluate the negative profile loglikelihood.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$nlp(psi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi}}{Kernel parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Value of the negative profile loglikelihood (scalar).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nu_hat"></a>}}
\if{latex}{\out{\hypertarget{method-nu_hat}{}}}
\subsection{Method \code{nu_hat()}}{
Conditional MLE of nuisance parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$nu_hat(phi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with elements \code{mu} and \code{Sigma}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-loglik"></a>}}
\if{latex}{\out{\hypertarget{method-loglik}{}}}
\subsection{Method \code{loglik()}}{
Evaluate the loglikelihood function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$loglik(phi, mu, Sigma)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Value of the loglikelihood (scalar).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fisher"></a>}}
\if{latex}{\out{\hypertarget{method-fisher}{}}}
\subsection{Method \code{fisher()}}{
Calculate the observed Fisher information matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$fisher(omega)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{omega}}{Vector of length \code{n_omega} of parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The \verb{n_omega x n_omega} observed Fisher information matrix.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_vcov"></a>}}
\if{latex}{\out{\hypertarget{method-get_vcov}{}}}
\subsection{Method \code{get_vcov()}}{
Convert a Fisher information matrix to a variance matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$get_vcov(fi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fi}}{Fisher information matrix of size \verb{n_omega x n_omega} with parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Variance matrix of size \verb{n_omega x n_omega} with parameters in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fit"></a>}}
\if{latex}{\out{\hypertarget{method-fit}{}}}
\subsection{Method \code{fit()}}{
Calculate the maximum likelihood parameter values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$fit(psi0, vcov = TRUE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi0}}{Vector of kernel parameter values (on the computational scale) to initialize the optimization if \code{n_phi > 1}.  If \code{n_phi == 1}, a vector of length 2 giving the range in which to perform the optimum search.}

\item{\code{vcov}}{Whether to also calculate the MLE variance estimate.}

\item{\code{...}}{Additional arguments to \code{\link[stats:optim]{stats::optim()}} or \code{\link[stats:optimize]{stats::optimize()}} for \code{n_phi == 1}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with elements \code{coef} and optionally \code{vcov} containing the MLE in the computational basis and its variance estimate.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-resid"></a>}}
\if{latex}{\out{\hypertarget{method-resid}{}}}
\subsection{Method \code{resid()}}{
Calculate the model residuals.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$resid(phi, mu, Sigma)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix of residuals the same size as \code{dX} as calculated with \code{\link[=csi_resid]{csi_resid()}}, upon using the model's \code{drift()} and \code{acf()} specifications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sim"></a>}}
\if{latex}{\out{\hypertarget{method-sim}{}}}
\subsection{Method \code{sim()}}{
Simulate trajectories from the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$sim(phi, mu, Sigma, nsim = 1, fft = TRUE, nkeep, tol = 1e-06)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}

\item{\code{nsim}}{Number of trajectories to simulate.}

\item{\code{fft, nkeep, tol}}{Optional arguments to \code{\link[SuperGauss:rnormtz]{SuperGauss::rnormtz()}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix of size \code{dim(Xt)} or an array of size \verb{nrow(Xt) x ncol(dX) x nsim} array when \code{nsim > 1} of simulated increments, as calculated with \code{\link[=csi_sim]{csi_sim()}}, using the model's \code{drift()} and \code{acf()} specifications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Model object constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$new(Xt, dt, drift = "linear", n_drift)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Xt}}{Matrix of particle positions.}

\item{\code{dt}}{Interobservation time.}

\item{\code{drift}}{Drift specification.  Either one of the strings "none", "linear", "quadratric", or a function with signature \verb{function(phi, dt, N)}.}

\item{\code{n_drift}}{Integer number of drift terms.  Ignored if \code{drift} is one of the default strings.  Required otherwise.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The value of \code{n_phi} is automatically determined from \code{phi_names}.  But this means the latter must be set by \code{derived$initialize()} before \code{super$initialize()} is called.  Otherwise an error is thrown.

The constructor can be called without \code{Xt} for accessing methods which don't require it, e.g.,\preformatted{derived$new(dt = dt)$acf(phi, dt, N)
}

\emph{Development Notes}
\itemize{
\item Should a validator be (optionally) called after the constructor?
\item Should \code{psi} necessarily contain the origin, to facilitate the validator?
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
