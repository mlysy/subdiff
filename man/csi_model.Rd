% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/csi_model.R
\name{csi_model}
\alias{csi_model}
\title{Base class for CSI models.}
\description{
Base class for CSI models.
}
\details{
Let \code{Xt} denote an \verb{N x d} matrix of particle positions recorded at intervals of \code{dt}, where \verb{d = 1,2,3} is the number of recorded dimensions.  A CSI model for \code{Xt} is of the form

\if{html}{\out{<div class="sourceCode">}}\preformatted{Xt = R(phi) mu + Sigma^\{1/2\} Z,
}\if{html}{\out{</div>}}

where:
\itemize{
\item \code{R(phi)} is an \verb{N x p} matrix of drift terms, possibly dependent on a parameter \code{phi}.  In most cases though, \code{R(phi) = t((1:N-1) * dt)} is used to model linear drift.
\item \code{mu} is a \verb{p x d} matrix of drift parameters.  For linear drift, it represents the drift velocity in each of the \code{d} dimensions.
\item \code{Sigma} is a \verb{d x d} variance matrix.
\item \code{Z} is an \verb{N x d} matrix where each column is an iid realization of \code{N} values of a Gaussian continuous stationary increments (CSI) process.  Such processes are completely determined by the mean square displacement (MSD) function

\if{html}{\out{<div class="sourceCode">}}\preformatted{MSD_Z(h) = E[ (Z_\{i+h,j\}, Z_\{i,j\})^2 ],
}\if{html}{\out{</div>}}

where the MSD function also depends on the parameter \code{phi}.
}

The \code{csi_model} class is a base class for CSI models which requires the user to specify the drift and msd functions, based on which it provides generic methods for parameter inference, simulation, etc.  For further details about the CSI model see \code{vignette("subdiff")}.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{phi_names}}{Vector of kernel parameter names (on the original scale).  Setting to \code{NULL} means there are no kernel parameters (\code{n_phi = 0}).}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{Xt}}{Particle trajectory.  A matrix where row \code{n} is the position of the particle at time \code{t = n * dt} and each column is a measurement dimension.  Only reallocates memory for the internal Toeplitz matrix if necessary.}

\item{\code{dt}}{Interobservation time (scalar).}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-csi_model-trans}{\code{csi_model$trans()}}
\item \href{#method-csi_model-itrans}{\code{csi_model$itrans()}}
\item \href{#method-csi_model-acf}{\code{csi_model$acf()}}
\item \href{#method-csi_model-msd}{\code{csi_model$msd()}}
\item \href{#method-csi_model-drift}{\code{csi_model$drift()}}
\item \href{#method-csi_model-get_omega}{\code{csi_model$get_omega()}}
\item \href{#method-csi_model-trans_full}{\code{csi_model$trans_full()}}
\item \href{#method-csi_model-itrans_full}{\code{csi_model$itrans_full()}}
\item \href{#method-csi_model-nlp}{\code{csi_model$nlp()}}
\item \href{#method-csi_model-nu_hat}{\code{csi_model$nu_hat()}}
\item \href{#method-csi_model-loglik}{\code{csi_model$loglik()}}
\item \href{#method-csi_model-fisher}{\code{csi_model$fisher()}}
\item \href{#method-csi_model-get_vcov}{\code{csi_model$get_vcov()}}
\item \href{#method-csi_model-fit}{\code{csi_model$fit()}}
\item \href{#method-csi_model-resid}{\code{csi_model$resid()}}
\item \href{#method-csi_model-sim}{\code{csi_model$sim()}}
\item \href{#method-csi_model-new}{\code{csi_model$new()}}
\item \href{#method-csi_model-clone}{\code{csi_model$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-trans"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-trans}{}}}
\subsection{Method \code{trans()}}{
Transform kernel parameters from regular to computational basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$trans(phi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Kernel parameters in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-itrans"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-itrans}{}}}
\subsection{Method \code{itrans()}}{
Transform kernel parameters from computational to regular basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$itrans(psi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi}}{Kernel parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Kernel parameters in the original basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-acf"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-acf}{}}}
\subsection{Method \code{acf()}}{
Increment autocorrelation function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$acf(phi, dt, N)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{dt}}{Interobservation time.}

\item{\code{N}}{Number of trajectory increments.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector of \code{N} autocorrelations.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-msd"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-msd}{}}}
\subsection{Method \code{msd()}}{
Position mean square displacement function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$msd(phi, t)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{t}}{Vector of time points at which to calculate the MSD.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method can be directly supplied by the derived class.  Otherwise, it uses \code{\link[SuperGauss:acf2msd]{SuperGauss::acf2msd()}} to calculate the MSD from \code{self$acf()} at intervals of \code{self$dt}, and interpolates linearly between these timepoints at the desired values in \code{t}.

The \code{self$msd()} method is defined this way because the MSD of some CSI models (e.g., \code{fsd} and \code{farma}) is not defined in continuous time, and thus intrinsically depends on the interobservation time \code{dt}.  Thus, the default \code{self$msd()} method throws an error if \code{self$dt} has not yet been set.
}

\subsection{Returns}{
A vector of \emph{unscaled} MSD values the same length as \code{t}.  That is, for the drift-subtracted process \code{X_sub(t) = X(t) - drift(t) * mu}, the method returns \code{eta(t)} where

\if{html}{\out{<div class="sourceCode">}}\preformatted{MSD_\{X_sub\}(t) = trace(Sigma) * eta(t).
}\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-drift"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-drift}{}}}
\subsection{Method \code{drift()}}{
Increment autocorrelation function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$drift(phi, dt, N)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{dt}}{Interobservation time.}

\item{\code{N}}{Number of trajectory increments.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \verb{N x n_drift} matrix of drift basis functions.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-get_omega"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-get_omega}{}}}
\subsection{Method \code{get_omega()}}{
Combine kernel parameters with conditional MLE of \code{mu} and \code{Sigma}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$get_omega(psi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi}}{Kernel parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Named vector of full parameter set in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-trans_full"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-trans_full}{}}}
\subsection{Method \code{trans_full()}}{
Convert from original to computational basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$trans_full(phi, mu, Sigma)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Full parameter vector in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-itrans_full"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-itrans_full}{}}}
\subsection{Method \code{itrans_full()}}{
Convert from computational to original basis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$itrans_full(omega)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{omega}}{Vector of parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements \code{phi}, \code{mu}, and \code{Sigma}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-nlp"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-nlp}{}}}
\subsection{Method \code{nlp()}}{
Evaluate the negative profile loglikelihood.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$nlp(psi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi}}{Kernel parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Value of the negative profile loglikelihood (scalar).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-nu_hat"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-nu_hat}{}}}
\subsection{Method \code{nu_hat()}}{
Conditional MLE of nuisance parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$nu_hat(phi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with elements \code{mu} and \code{Sigma}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-loglik"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-loglik}{}}}
\subsection{Method \code{loglik()}}{
Evaluate the loglikelihood function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$loglik(phi, mu, Sigma)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Value of the loglikelihood (scalar).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-fisher"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-fisher}{}}}
\subsection{Method \code{fisher()}}{
Calculate the observed Fisher information matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$fisher(omega)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{omega}}{Vector of length \code{n_omega} of parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The \verb{n_omega x n_omega} observed Fisher information matrix.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-get_vcov"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-get_vcov}{}}}
\subsection{Method \code{get_vcov()}}{
Convert a Fisher information matrix to a variance matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$get_vcov(fi)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fi}}{Fisher information matrix of size \verb{n_omega x n_omega} with parameters in the computational basis.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Variance matrix of size \verb{n_omega x n_omega} with parameters in the computational basis.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-fit"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-fit}{}}}
\subsection{Method \code{fit()}}{
Calculate the maximum likelihood parameter values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$fit(psi0, vcov = TRUE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{psi0}}{Vector of kernel parameter values (on the computational scale) to initialize the optimization if \code{n_phi > 1}.  If \code{n_phi == 1}, a vector of length 2 giving the range in which to perform the optimum search.}

\item{\code{vcov}}{Whether to also calculate the MLE variance estimate.}

\item{\code{...}}{Additional arguments to \code{\link[stats:optim]{stats::optim()}} or \code{\link[stats:optimize]{stats::optimize()}} for \code{n_phi == 1}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with elements \code{coef} and optionally \code{vcov} containing the MLE in the computational basis and its variance estimate.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-resid"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-resid}{}}}
\subsection{Method \code{resid()}}{
Calculate the model residuals.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$resid(phi, mu, Sigma)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix of residuals the same size as \code{dX} as calculated with \code{\link[=csi_resid]{csi_resid()}}, upon using the model's \code{drift()} and \code{acf()} specifications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-sim"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-sim}{}}}
\subsection{Method \code{sim()}}{
Simulate trajectories from the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$sim(phi, mu, Sigma, nsim = 1, fft = TRUE, nkeep, tol = 1e-06)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{phi}}{Kernel parameters in the original basis.}

\item{\code{mu}}{Drift coefficients.}

\item{\code{Sigma}}{Scale matrix.}

\item{\code{nsim}}{Number of trajectories to simulate.}

\item{\code{fft, nkeep, tol}}{Optional arguments to \code{\link[SuperGauss:rnormtz]{SuperGauss::rnormtz()}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A matrix of size \code{dim(Xt)} or an array of size \verb{nrow(Xt) x ncol(dX) x nsim} array when \code{nsim > 1} of simulated trajectories, as calculated with \code{\link[=csi_sim]{csi_sim()}}, using the model's \code{drift()} and \code{acf()} specifications.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-new"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-new}{}}}
\subsection{Method \code{new()}}{
Model object constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$new(Xt, dt, drift = "linear", n_drift)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Xt}}{Matrix of particle positions.}

\item{\code{dt}}{Interobservation time.}

\item{\code{drift}}{Drift specification.  Either one of the strings "none", "linear", "quadratric", or a function with signature \verb{function(phi, dt, N)}.}

\item{\code{n_drift}}{Integer number of drift terms.  Ignored if \code{drift} is one of the default strings.  Required otherwise.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The value of \code{n_phi} is automatically determined from \code{phi_names}.  But this means the latter must be set by \code{derived$initialize()} before \code{super$initialize()} is called.  Otherwise an error is thrown.

The constructor can be called without \code{Xt} for accessing methods which don't require it, e.g.,

\if{html}{\out{<div class="sourceCode">}}\preformatted{derived$new(dt = dt)$acf(phi, dt, N)
}\if{html}{\out{</div>}}

\emph{Development Notes}
\itemize{
\item Should a validator be (optionally) called after the constructor?
\item Should \code{psi} necessarily contain the origin, to facilitate the validator?
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-csi_model-clone"></a>}}
\if{latex}{\out{\hypertarget{method-csi_model-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{csi_model$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
